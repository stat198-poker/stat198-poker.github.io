{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getId, toMatrix, classNamesFunction, getNativeProps, htmlElementProperties, initializeComponentRef } from '../../Utilities';\nimport { FocusZone } from '../../FocusZone';\nvar getClassNames = classNamesFunction();\n\nvar GridBase =\n/** @class */\nfunction (_super) {\n  __extends(GridBase, _super);\n\n  function GridBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    initializeComponentRef(_this);\n    _this._id = props.id || getId();\n    return _this;\n  }\n\n  GridBase.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var items = props.items,\n        columnCount = props.columnCount,\n        onRenderItem = props.onRenderItem,\n        // tslint:disable:deprecation\n    _a = props.ariaPosInSet,\n        // tslint:disable:deprecation\n    ariaPosInSet = _a === void 0 ? props.positionInSet : _a,\n        _b = props.ariaSetSize,\n        ariaSetSize = _b === void 0 ? props.setSize : _b,\n        // tslint:enable:deprecation\n    styles = props.styles,\n        doNotContainWithinFocusZone = props.doNotContainWithinFocusZone;\n    var htmlProps = getNativeProps(this.props, htmlElementProperties, // avoid applying onBlur on the table if it's being used in the FocusZone\n    doNotContainWithinFocusZone ? [] : ['onBlur']);\n    var classNames = getClassNames(styles, {\n      theme: this.props.theme\n    }); // Array to store the cells in the correct row index\n\n    var rowsOfItems = toMatrix(items, columnCount);\n    var content = React.createElement(\"table\", __assign({\n      \"aria-posinset\": ariaPosInSet,\n      \"aria-setsize\": ariaSetSize,\n      id: this._id,\n      role: \"grid\"\n    }, htmlProps, {\n      className: classNames.root\n    }), React.createElement(\"tbody\", null, rowsOfItems.map(function (rows, rowIndex) {\n      return React.createElement(\"tr\", {\n        role: 'row',\n        key: _this._id + '-' + rowIndex + '-row'\n      }, rows.map(function (cell, cellIndex) {\n        return React.createElement(\"td\", {\n          role: 'presentation',\n          key: _this._id + '-' + cellIndex + '-cell',\n          className: classNames.tableCell\n        }, onRenderItem(cell, cellIndex));\n      }));\n    }))); // Create the table/grid\n\n    return doNotContainWithinFocusZone ? content : React.createElement(FocusZone, {\n      isCircularNavigation: this.props.shouldFocusCircularNavigate,\n      className: classNames.focusedContainer,\n      onBlur: this.props.onBlur\n    }, content);\n  };\n\n  return GridBase;\n}(React.Component);\n\nexport { GridBase };","map":{"version":3,"sources":["utilities/grid/Grid.base.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getId,\n  toMatrix,\n  classNamesFunction,\n  getNativeProps,\n  htmlElementProperties,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { FocusZone } from '../../FocusZone';\nimport { IGrid, IGridProps, IGridStyleProps, IGridStyles } from './Grid.types';\n\nconst getClassNames = classNamesFunction<IGridStyleProps, IGridStyles>();\n\nexport class GridBase extends React.Component<IGridProps, {}> implements IGrid {\n  private _id: string;\n\n  constructor(props: IGridProps) {\n    super(props);\n\n    initializeComponentRef(this);\n    this._id = props.id || getId();\n  }\n\n  public render(): JSX.Element {\n    const props = this.props;\n    const {\n      items,\n      columnCount,\n      onRenderItem,\n\n      // tslint:disable:deprecation\n      ariaPosInSet = props.positionInSet,\n      ariaSetSize = props.setSize,\n      // tslint:enable:deprecation\n\n      styles,\n      doNotContainWithinFocusZone,\n    } = props;\n\n    const htmlProps = getNativeProps<React.HTMLAttributes<HTMLTableElement>>(\n      this.props,\n      htmlElementProperties,\n      // avoid applying onBlur on the table if it's being used in the FocusZone\n      doNotContainWithinFocusZone ? [] : ['onBlur'],\n    );\n\n    const classNames = getClassNames(styles!, { theme: this.props.theme! });\n\n    // Array to store the cells in the correct row index\n    const rowsOfItems: any[][] = toMatrix(items, columnCount);\n\n    const content = (\n      <table\n        aria-posinset={ariaPosInSet}\n        aria-setsize={ariaSetSize}\n        id={this._id}\n        role=\"grid\"\n        {...htmlProps}\n        className={classNames.root}\n      >\n        <tbody>\n          {rowsOfItems.map((rows: any[], rowIndex: number) => {\n            return (\n              <tr role={'row'} key={this._id + '-' + rowIndex + '-row'}>\n                {rows.map((cell: any, cellIndex: number) => {\n                  return (\n                    <td\n                      role={'presentation'}\n                      key={this._id + '-' + cellIndex + '-cell'}\n                      className={classNames.tableCell}\n                    >\n                      {onRenderItem(cell, cellIndex)}\n                    </td>\n                  );\n                })}\n              </tr>\n            );\n          })}\n        </tbody>\n      </table>\n    );\n\n    // Create the table/grid\n    return doNotContainWithinFocusZone ? (\n      content\n    ) : (\n      <FocusZone\n        isCircularNavigation={this.props.shouldFocusCircularNavigate}\n        className={classNames.focusedContainer}\n        onBlur={this.props.onBlur}\n      >\n        {content}\n      </FocusZone>\n    );\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}