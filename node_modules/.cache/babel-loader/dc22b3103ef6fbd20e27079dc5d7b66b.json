{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, KeyCodes, css, elementContains, getId, classNamesFunction, styled, initializeComponentRef } from '../../Utilities';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport { ValidationState } from './BasePicker.types';\nimport { Autofill } from '../Autofill/index';\nimport * as stylesImport from './BasePicker.scss';\nvar legacyStyles = stylesImport;\nvar getClassNames = classNamesFunction();\n/**\n * Should be removed once new picker without inheritance is created\n */\n\nfunction getStyledSuggestions(suggestionsType) {\n  return styled(suggestionsType, suggestionsStyles, undefined, {\n    scope: 'Suggestions'\n  });\n}\n/**\n * {@docCategory Pickers}\n */\n\n\nvar BasePicker =\n/** @class */\nfunction (_super) {\n  __extends(BasePicker, _super);\n\n  function BasePicker(basePickerProps) {\n    var _this = _super.call(this, basePickerProps) || this; // Refs\n\n\n    _this.root = React.createRef();\n    _this.input = React.createRef();\n    _this.focusZone = React.createRef();\n    _this.suggestionElement = React.createRef();\n    /**\n     * @deprecated this is no longer necessary as typescript now supports generic elements\n     */\n\n    _this.SuggestionOfProperType = Suggestions; // tslint:disable-next-line:deprecation\n\n    _this._styledSuggestions = getStyledSuggestions(_this.SuggestionOfProperType);\n\n    _this.dismissSuggestions = function (ev) {\n      var selectItemFunction = function () {\n        if (_this.props.onDismiss) {\n          _this.props.onDismiss(ev, _this.suggestionStore.currentSuggestion ? _this.suggestionStore.currentSuggestion.item : undefined);\n        }\n\n        if (!ev || ev && !ev.defaultPrevented) {\n          // Select the first suggestion if one is available when user leaves.\n          if (_this.canAddItems() && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestedDisplayValue) {\n            _this.addItemByIndex(0);\n          }\n        }\n      };\n\n      if (_this.currentPromise) {\n        _this.currentPromise.then(function () {\n          return selectItemFunction();\n        });\n      } else {\n        selectItemFunction();\n      }\n\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n\n    _this.refocusSuggestions = function (keyCode) {\n      _this.resetFocus();\n\n      if (_this.suggestionStore.suggestions && _this.suggestionStore.suggestions.length > 0) {\n        if (keyCode === KeyCodes.up) {\n          _this.suggestionStore.setSelectedSuggestion(_this.suggestionStore.suggestions.length - 1);\n        } else if (keyCode === KeyCodes.down) {\n          _this.suggestionStore.setSelectedSuggestion(0);\n        }\n      }\n    };\n\n    _this.onInputChange = function (value) {\n      _this.updateValue(value);\n\n      _this.setState({\n        moreSuggestionsAvailable: true,\n        isMostRecentlyUsedVisible: false\n      });\n    };\n\n    _this.onSuggestionClick = function (ev, item, index) {\n      _this.addItemByIndex(index);\n    };\n\n    _this.onSuggestionRemove = function (ev, item, index) {\n      if (_this.props.onRemoveSuggestion) {\n        _this.props.onRemoveSuggestion(item);\n      }\n\n      _this.suggestionStore.removeSuggestion(index);\n    };\n\n    _this.onInputFocus = function (ev) {\n      // Only trigger all of the focus if this component isn't already focused.\n      // For example when an item is selected or removed from the selected list it should be treated\n      // as though the input is still focused.\n      if (!_this.state.isFocused) {\n        _this.setState({\n          isFocused: true\n        });\n\n        _this.selection.setAllSelected(false);\n\n        _this._userTriggeredSuggestions();\n\n        if (_this.props.inputProps && _this.props.inputProps.onFocus) {\n          _this.props.inputProps.onFocus(ev);\n        }\n      }\n    };\n\n    _this.onInputBlur = function (ev) {\n      if (_this.props.inputProps && _this.props.inputProps.onBlur) {\n        _this.props.inputProps.onBlur(ev);\n      }\n    };\n\n    _this.onBlur = function (ev) {\n      if (_this.state.isFocused) {\n        // Only blur the entire component if an unrelated element gets focus.\n        // Otherwise treat it as though it still has focus.\n        // Do nothing if the blur is coming from something\n        // inside the comboBox root or the comboBox menu since\n        // it we are not really bluring from the whole comboBox\n        var relatedTarget = ev.relatedTarget;\n\n        if (ev.relatedTarget === null) {\n          // In IE11, due to lack of support, event.relatedTarget is always\n          // null making every onBlur call to be \"outside\" of the ComboBox\n          // even when it's not. Using document.activeElement is another way\n          // for us to be able to get what the relatedTarget without relying\n          // on the event\n          relatedTarget = document.activeElement;\n        }\n\n        if (relatedTarget && !elementContains(_this.root.current, relatedTarget)) {\n          _this.setState({\n            isFocused: false\n          });\n\n          if (_this.props.onBlur) {\n            _this.props.onBlur(ev);\n          }\n        }\n      }\n    };\n    /**\n     * Reveals suggestions any time the user clicks on the input element\n     * without shifting focus.\n     */\n\n\n    _this.onClick = function (ev) {\n      if (_this.props.inputProps !== undefined && _this.props.inputProps.onClick !== undefined) {\n        _this.props.inputProps.onClick(ev);\n      } // Only primary (left) clicks show suggestions.\n\n\n      if (ev.button === 0) {\n        _this._userTriggeredSuggestions();\n      }\n    };\n\n    _this.onKeyDown = function (ev) {\n      var keyCode = ev.which;\n\n      switch (keyCode) {\n        case KeyCodes.escape:\n          if (_this.state.suggestionsVisible) {\n            _this.setState({\n              suggestionsVisible: false\n            });\n\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n\n          break;\n\n        case KeyCodes.tab:\n        case KeyCodes.enter:\n          if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedActionSelected()) {\n            _this.suggestionElement.current.executeSelectedAction();\n          } else if (!ev.shiftKey && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestionsVisible) {\n            _this.completeSuggestion();\n\n            ev.preventDefault();\n            ev.stopPropagation();\n          } else {\n            _this._completeGenericSuggestion();\n          }\n\n          break;\n\n        case KeyCodes.backspace:\n          if (!_this.props.disabled) {\n            _this.onBackspace(ev);\n          }\n\n          ev.stopPropagation();\n          break;\n\n        case KeyCodes.del:\n          if (!_this.props.disabled) {\n            if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible && _this.suggestionStore.currentIndex !== -1) {\n              if (_this.props.onRemoveSuggestion) {\n                _this.props.onRemoveSuggestion(_this.suggestionStore.currentSuggestion.item);\n              }\n\n              _this.suggestionStore.removeSuggestion(_this.suggestionStore.currentIndex);\n\n              _this.forceUpdate();\n            } else {\n              _this.onBackspace(ev);\n            }\n          }\n\n          ev.stopPropagation();\n          break;\n\n        case KeyCodes.up:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex === 0) {\n                ev.preventDefault();\n                ev.stopPropagation();\n\n                _this.suggestionElement.current.focusAboveSuggestions();\n\n                _this.suggestionStore.deselectAllSuggestions();\n\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.previousSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n\n          break;\n\n        case KeyCodes.down:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex + 1 === _this.suggestionStore.suggestions.length) {\n                ev.preventDefault();\n                ev.stopPropagation();\n\n                _this.suggestionElement.current.focusBelowSuggestions();\n\n                _this.suggestionStore.deselectAllSuggestions();\n\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.nextSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n\n          break;\n      }\n    };\n\n    _this.onItemChange = function (changedItem, index) {\n      var items = _this.state.items;\n\n      if (index >= 0) {\n        var newItems = items;\n        newItems[index] = changedItem;\n\n        _this._updateSelectedItems(newItems);\n      }\n    };\n\n    _this.onGetMoreResults = function () {\n      _this.setState({\n        isSearching: true\n      }, function () {\n        if (_this.props.onGetMoreResults && _this.input.current) {\n          var suggestions = _this.props.onGetMoreResults(_this.input.current.value, _this.state.items);\n\n          var suggestionsArray = suggestions;\n          var suggestionsPromiseLike = suggestions;\n\n          if (Array.isArray(suggestionsArray)) {\n            _this.updateSuggestions(suggestionsArray);\n\n            _this.setState({\n              isSearching: false\n            });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then(function (newSuggestions) {\n              _this.updateSuggestions(newSuggestions);\n\n              _this.setState({\n                isSearching: false\n              });\n            });\n          }\n        } else {\n          _this.setState({\n            isSearching: false\n          });\n        }\n\n        if (_this.input.current) {\n          _this.input.current.focus();\n        }\n\n        _this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true\n        });\n      });\n    };\n\n    _this.completeSelection = function (item) {\n      _this.addItem(item);\n\n      _this.updateValue('');\n\n      if (_this.input.current) {\n        _this.input.current.clear();\n      }\n\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n\n    _this.addItemByIndex = function (index) {\n      _this.completeSelection(_this.suggestionStore.getSuggestionAtIndex(index).item);\n    };\n\n    _this.addItem = function (item) {\n      var processedItem = _this.props.onItemSelected ? _this.props.onItemSelected(item) : item;\n\n      if (processedItem === null) {\n        return;\n      }\n\n      var processedItemObject = processedItem;\n      var processedItemPromiseLike = processedItem;\n\n      if (processedItemPromiseLike && processedItemPromiseLike.then) {\n        processedItemPromiseLike.then(function (resolvedProcessedItem) {\n          var newItems = _this.state.items.concat([resolvedProcessedItem]);\n\n          _this._updateSelectedItems(newItems);\n        });\n      } else {\n        var newItems = _this.state.items.concat([processedItemObject]);\n\n        _this._updateSelectedItems(newItems);\n      }\n\n      _this.setState({\n        suggestedDisplayValue: ''\n      });\n    };\n\n    _this.removeItem = function (item, focusNextItem) {\n      var items = _this.state.items;\n      var index = items.indexOf(item);\n\n      if (index >= 0) {\n        var newItems = items.slice(0, index).concat(items.slice(index + 1));\n\n        _this._updateSelectedItems(newItems, focusNextItem ? index : undefined);\n      }\n    };\n\n    _this.removeItems = function (itemsToRemove) {\n      var items = _this.state.items;\n      var newItems = items.filter(function (item) {\n        return itemsToRemove.indexOf(item) === -1;\n      });\n      var firstItemToRemove = itemsToRemove[0];\n      var index = items.indexOf(firstItemToRemove);\n\n      _this._updateSelectedItems(newItems, index);\n    };\n\n    _this._shouldFocusZoneEnterInnerZone = function (ev) {\n      // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n      if (_this.state.suggestionsVisible) {\n        switch (ev.which) {\n          case KeyCodes.up:\n          case KeyCodes.down:\n            return true;\n        }\n      }\n\n      if (ev.which === KeyCodes.enter) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this._onResolveSuggestions = function (updatedValue) {\n      var suggestions = _this.props.onResolveSuggestions(updatedValue, _this.state.items);\n\n      if (suggestions !== null) {\n        _this.updateSuggestionsList(suggestions, updatedValue);\n      }\n    };\n\n    _this._completeGenericSuggestion = function () {\n      if (_this.props.onValidateInput && _this.input.current && _this.props.onValidateInput(_this.input.current.value) !== ValidationState.invalid && _this.props.createGenericItem) {\n        var itemToConvert = _this.props.createGenericItem(_this.input.current.value, _this.props.onValidateInput(_this.input.current.value));\n\n        _this.suggestionStore.createGenericSuggestion(itemToConvert);\n\n        _this.completeSuggestion();\n      }\n    };\n    /**\n     * This should be called when the user does something other than use text entry to trigger suggestions.\n     *\n     */\n\n\n    _this._userTriggeredSuggestions = function () {\n      if (!_this.state.suggestionsVisible) {\n        var input = _this.input.current ? _this.input.current.value : '';\n\n        if (!input) {\n          _this.onEmptyInputFocus();\n        } else {\n          if (_this.suggestionStore.suggestions.length === 0) {\n            _this._onResolveSuggestions(input);\n          } else {\n            _this.setState({\n              isMostRecentlyUsedVisible: false,\n              suggestionsVisible: true\n            });\n          }\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    var items = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n    _this._id = getId();\n    _this._ariaMap = {\n      selectedItems: \"selected-items-\" + _this._id,\n      selectedSuggestionAlert: \"selected-suggestion-alert-\" + _this._id,\n      suggestionList: \"suggestion-list-\" + _this._id\n    };\n    _this.suggestionStore = new SuggestionsController();\n    _this.selection = new Selection({\n      onSelectionChanged: function () {\n        return _this.onSelectionChange();\n      }\n    });\n\n    _this.selection.setItems(items);\n\n    _this.state = {\n      items: items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: []\n    };\n    return _this;\n  }\n\n  Object.defineProperty(BasePicker.prototype, \"items\", {\n    get: function () {\n      return this.state.items;\n    },\n    enumerable: true,\n    configurable: true\n  }); // tslint:disable-next-line function-name\n\n  BasePicker.prototype.UNSAFE_componentWillUpdate = function (newProps, newState) {\n    if (newState.items && newState.items !== this.state.items) {\n      this.selection.setItems(newState.items);\n    }\n  };\n\n  BasePicker.prototype.componentDidMount = function () {\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  }; // tslint:disable-next-line function-name\n\n\n  BasePicker.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    var _this = this;\n\n    var newItems = newProps.selectedItems;\n\n    if (newItems) {\n      var focusIndex_1; // If there are less new items than old items then something was removed and we\n      // should try to keep focus consistent\n\n      if (newItems.length < this.state.items.length) {\n        focusIndex_1 = this.state.items.indexOf(this.selection.getSelection()[0]);\n      }\n\n      this.setState({\n        items: newProps.selectedItems\n      }, function () {\n        // Only update the focus if this component is currently focused to ensure that the basepicker\n        // doesn't steal focus from something else.\n        if (_this.state.isFocused) {\n          // Need to reset focus in the same that way that we do if an item is selected by a non-controlled component\n          // See _onSelectedItemsUpdated.\n          _this.resetFocus(focusIndex_1);\n        }\n      });\n    }\n  };\n\n  BasePicker.prototype.componentWillUnmount = function () {\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n\n    this._async.dispose();\n  };\n\n  BasePicker.prototype.focus = function () {\n    if (this.focusZone.current) {\n      this.focusZone.current.focus();\n    }\n  };\n\n  BasePicker.prototype.focusInput = function () {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  };\n\n  BasePicker.prototype.completeSuggestion = function (forceComplete) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  };\n\n  BasePicker.prototype.render = function () {\n    var _a = this.state,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        isFocused = _a.isFocused,\n        items = _a.items;\n    var _b = this.props,\n        className = _b.className,\n        inputProps = _b.inputProps,\n        disabled = _b.disabled,\n        theme = _b.theme,\n        styles = _b.styles;\n    var selectedSuggestionAlertId = this.props.enableSelectedSuggestionAlert ? this._ariaMap.selectedSuggestionAlert : '';\n    var suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : ''; // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      disabled: disabled,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n      itemsWrapper: legacyStyles.pickerItems,\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    return React.createElement(\"div\", {\n      ref: this.root,\n      className: classNames.root,\n      onKeyDown: this.onKeyDown,\n      onBlur: this.onBlur\n    }, React.createElement(FocusZone, {\n      componentRef: this.focusZone,\n      direction: FocusZoneDirection.bidirectional,\n      shouldEnterInnerZone: this._shouldFocusZoneEnterInnerZone,\n      role: 'combobox',\n      \"aria-expanded\": !!this.state.suggestionsVisible,\n      \"aria-owns\": suggestionsAvailable || undefined,\n      \"aria-haspopup\": suggestionsAvailable && this.suggestionStore.suggestions.length > 0 ? 'listbox' : 'dialog'\n    }, this.getSuggestionsAlert(classNames.screenReaderText), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.multiple\n    }, React.createElement(\"div\", {\n      className: classNames.text\n    }, items.length > 0 && React.createElement(\"span\", {\n      id: this._ariaMap.selectedItems,\n      className: classNames.itemsWrapper,\n      role: 'list'\n    }, this.renderItems()), this.canAddItems() && React.createElement(Autofill, __assign({\n      spellCheck: false\n    }, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      onClick: this.onClick,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-describedby\": items.length > 0 ? this._ariaMap.selectedItems : undefined,\n      \"aria-controls\": suggestionsAvailable + \" \" + selectedSuggestionAlertId || undefined,\n      \"aria-activedescendant\": this.getActiveDescendant(),\n      role: 'textbox',\n      disabled: disabled,\n      onInputChange: this.props.onInputChange\n    }))))), this.renderSuggestions());\n  };\n\n  BasePicker.prototype.canAddItems = function () {\n    var items = this.state.items;\n    var itemLimit = this.props.itemLimit;\n    return itemLimit === undefined || items.length < itemLimit;\n  };\n\n  BasePicker.prototype.renderSuggestions = function () {\n    var StyledTypedSuggestions = this._styledSuggestions;\n    return this.state.suggestionsVisible && this.input ? React.createElement(Callout, __assign({\n      isBeakVisible: false,\n      gapSpace: 5,\n      target: this.input.current ? this.input.current.inputElement : undefined,\n      onDismiss: this.dismissSuggestions,\n      directionalHint: DirectionalHint.bottomLeftEdge,\n      directionalHintForRTL: DirectionalHint.bottomRightEdge\n    }, this.props.pickerCalloutProps), React.createElement(StyledTypedSuggestions // Assumed to set in derived component's defaultProps\n    , __assign({\n      // Assumed to set in derived component's defaultProps\n      onRenderSuggestion: this.props.onRenderSuggestionsItem,\n      onSuggestionClick: this.onSuggestionClick,\n      onSuggestionRemove: this.onSuggestionRemove,\n      suggestions: this.suggestionStore.getSuggestions(),\n      componentRef: this.suggestionElement,\n      onGetMoreResults: this.onGetMoreResults,\n      moreSuggestionsAvailable: this.state.moreSuggestionsAvailable,\n      isLoading: this.state.suggestionsLoading,\n      isSearching: this.state.isSearching,\n      isMostRecentlyUsedVisible: this.state.isMostRecentlyUsedVisible,\n      isResultsFooterVisible: this.state.isResultsFooterVisible,\n      refocusSuggestions: this.refocusSuggestions,\n      removeSuggestionAriaLabel: this.props.removeButtonAriaLabel,\n      suggestionsListId: this._ariaMap.suggestionList,\n      createGenericItem: this._completeGenericSuggestion\n    }, this.props.pickerSuggestionsProps))) : null;\n  };\n\n  BasePicker.prototype.renderItems = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        removeButtonAriaLabel = _a.removeButtonAriaLabel;\n    var onRenderItem = this.props.onRenderItem;\n    var _b = this.state,\n        items = _b.items,\n        selectedIndices = _b.selectedIndices;\n    return items.map(function (item, index) {\n      return onRenderItem({\n        item: item,\n        index: index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices.indexOf(index) !== -1,\n        onRemoveItem: function () {\n          return _this.removeItem(item, true);\n        },\n        disabled: disabled,\n        onItemChange: _this.onItemChange,\n        removeButtonAriaLabel: removeButtonAriaLabel\n      });\n    });\n  };\n\n  BasePicker.prototype.resetFocus = function (index) {\n    var items = this.state.items;\n\n    if (items.length && index >= 0) {\n      var newEl = this.root.current && this.root.current.querySelectorAll('[data-selection-index]')[Math.min(index, items.length - 1)];\n\n      if (newEl && this.focusZone.current) {\n        this.focusZone.current.focusElement(newEl);\n      }\n    } else if (!this.canAddItems()) {\n      this.resetFocus(items.length - 1);\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  };\n\n  BasePicker.prototype.onSuggestionSelect = function () {\n    if (this.suggestionStore.currentSuggestion) {\n      var currentValue = this.input.current ? this.input.current.value : '';\n\n      var itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n\n      this.setState({\n        suggestedDisplayValue: itemValue\n      });\n    }\n  };\n\n  BasePicker.prototype.onSelectionChange = function () {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices()\n    });\n  };\n\n  BasePicker.prototype.updateSuggestions = function (suggestions) {\n    this.suggestionStore.updateSuggestions(suggestions, 0);\n    this.forceUpdate();\n  };\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n\n\n  BasePicker.prototype.onEmptyInputFocus = function () {\n    var emptyResolveSuggestions = this.props.onEmptyResolveSuggestions ? this.props.onEmptyResolveSuggestions : // tslint:disable-next-line:deprecation\n    this.props.onEmptyInputFocus; // Only attempt to resolve suggestions if it exists\n\n    if (emptyResolveSuggestions) {\n      var suggestions = emptyResolveSuggestions(this.state.items);\n      this.updateSuggestionsList(suggestions);\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false\n      });\n    }\n  };\n\n  BasePicker.prototype.updateValue = function (updatedValue) {\n    this._onResolveSuggestions(updatedValue);\n  };\n\n  BasePicker.prototype.updateSuggestionsList = function (suggestions, updatedValue) {\n    var _this = this;\n\n    var suggestionsArray = suggestions;\n    var suggestionsPromiseLike = suggestions; // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n\n    if (Array.isArray(suggestionsArray)) {\n      this._updateAndResolveValue(updatedValue, suggestionsArray);\n    } else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {\n      this.setState({\n        suggestionsLoading: true\n      }); // Clear suggestions\n\n      this.suggestionStore.updateSuggestions([]);\n\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions()\n        });\n      } else {\n        this.setState({\n          suggestionsVisible: this.input.current && this.input.current.inputElement === document.activeElement\n        });\n      } // Ensure that the promise will only use the callback if it was the most recent one.\n\n\n      var promise_1 = this.currentPromise = suggestionsPromiseLike;\n      promise_1.then(function (newSuggestions) {\n        if (promise_1 === _this.currentPromise) {\n          _this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  };\n\n  BasePicker.prototype.resolveNewValue = function (updatedValue, suggestions) {\n    var _this = this;\n\n    this.updateSuggestions(suggestions);\n    var itemValue = undefined;\n\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    } // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n\n\n    this.setState({\n      suggestedDisplayValue: itemValue,\n      suggestionsVisible: this._getShowSuggestions()\n    }, function () {\n      return _this.setState({\n        suggestionsLoading: false\n      });\n    });\n  };\n\n  BasePicker.prototype.onChange = function (items) {\n    if (this.props.onChange) {\n      this.props.onChange(items);\n    }\n  }; // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n\n\n  BasePicker.prototype.onBackspace = function (ev) {\n    if (this.state.items.length && !this.input.current || this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  };\n\n  BasePicker.prototype.getActiveDescendant = function () {\n    var currentIndex = this.suggestionStore.currentIndex;\n    return currentIndex > -1 && !this.state.suggestionsLoading ? 'sug-' + currentIndex : undefined;\n  };\n\n  BasePicker.prototype.getSuggestionsAlert = function (suggestionAlertClassName) {\n    if (suggestionAlertClassName === void 0) {\n      suggestionAlertClassName = legacyStyles.screenReaderOnly;\n    }\n\n    var currentIndex = this.suggestionStore.currentIndex;\n\n    if (this.props.enableSelectedSuggestionAlert) {\n      var selectedSuggestion = currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      var selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;\n      return React.createElement(\"div\", {\n        className: suggestionAlertClassName,\n        role: \"alert\",\n        id: this._ariaMap.selectedSuggestionAlert,\n        \"aria-live\": \"assertive\"\n      }, selectedSuggestionAlertText, ' ');\n    }\n  };\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n\n\n  BasePicker.prototype._updateAndResolveValue = function (updatedValue, newSuggestions) {\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      this.suggestionStore.updateSuggestions(newSuggestions, -1);\n\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false\n        });\n      }\n    }\n  };\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n\n\n  BasePicker.prototype._updateSelectedItems = function (items, focusIndex) {\n    var _this = this;\n\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({\n        items: items\n      }, function () {\n        _this._onSelectedItemsUpdated(items, focusIndex);\n      });\n    }\n  };\n\n  BasePicker.prototype._onSelectedItemsUpdated = function (items, focusIndex) {\n    this.resetFocus(focusIndex);\n    this.onChange(items);\n  };\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n\n\n  BasePicker.prototype._getShowSuggestions = function () {\n    var areSuggestionsVisible = this.input.current !== undefined && this.input.current !== null && this.input.current.inputElement === document.activeElement && this.input.current.value !== '';\n    return areSuggestionsVisible;\n  };\n\n  BasePicker.prototype._getTextFromItem = function (item, currentValue) {\n    if (this.props.getTextFromItem) {\n      return this.props.getTextFromItem(item, currentValue);\n    } else {\n      return '';\n    }\n  };\n\n  return BasePicker;\n}(React.Component);\n\nexport { BasePicker };\n\nvar BasePickerListBelow =\n/** @class */\nfunction (_super) {\n  __extends(BasePickerListBelow, _super);\n\n  function BasePickerListBelow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  BasePickerListBelow.prototype.render = function () {\n    var _a = this.state,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        isFocused = _a.isFocused;\n    var _b = this.props,\n        className = _b.className,\n        inputProps = _b.inputProps,\n        disabled = _b.disabled,\n        theme = _b.theme,\n        styles = _b.styles;\n    var selectedSuggestionAlertId = this.props.enableSelectedSuggestionAlert ? this._ariaMap.selectedSuggestionAlert : '';\n    var suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : ''; // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    return React.createElement(\"div\", {\n      ref: this.root,\n      onBlur: this.onBlur\n    }, React.createElement(\"div\", {\n      className: classNames.root,\n      onKeyDown: this.onKeyDown\n    }, this.getSuggestionsAlert(classNames.screenReaderText), React.createElement(\"div\", {\n      className: classNames.text,\n      \"aria-owns\": suggestionsAvailable || undefined,\n      \"aria-expanded\": !!this.state.suggestionsVisible,\n      \"aria-haspopup\": suggestionsAvailable && this.suggestionStore.suggestions.length > 0 ? 'listbox' : 'dialog',\n      role: \"combobox\"\n    }, React.createElement(Autofill, __assign({}, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onClick: this.onClick,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-activedescendant\": this.getActiveDescendant(),\n      role: \"textbox\",\n      disabled: disabled,\n      \"aria-controls\": suggestionsAvailable + \" \" + selectedSuggestionAlertId || undefined,\n      onInputChange: this.props.onInputChange\n    })))), this.renderSuggestions(), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.single\n    }, React.createElement(FocusZone, {\n      componentRef: this.focusZone,\n      className: \"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n      ,\n      isCircularNavigation: true,\n      direction: FocusZoneDirection.bidirectional,\n      shouldEnterInnerZone: this._shouldFocusZoneEnterInnerZone,\n      id: this._ariaMap.selectedItems,\n      role: 'list'\n    }, this.renderItems())));\n  };\n\n  BasePickerListBelow.prototype.onBackspace = function (ev) {// override the existing backspace method to not do anything because the list items appear below.\n  };\n\n  return BasePickerListBelow;\n}(BasePicker);\n\nexport { BasePickerListBelow };","map":{"version":3,"sources":["components/pickers/BasePicker.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  Async,\n  KeyCodes,\n  css,\n  elementContains,\n  getId,\n  classNamesFunction,\n  styled,\n  initializeComponentRef,\n} from '../../Utilities';\nimport { IProcessedStyleSet } from '../../Styling';\nimport { IFocusZone, FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport {\n  ISuggestions,\n  ISuggestionsProps,\n  ISuggestionsStyleProps,\n  ISuggestionsStyles,\n} from './Suggestions/Suggestions.types';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport {\n  IBasePicker,\n  IBasePickerProps,\n  ValidationState,\n  IBasePickerStyleProps,\n  IBasePickerStyles,\n} from './BasePicker.types';\nimport { IAutofill, Autofill } from '../Autofill/index';\nimport { IPickerItemProps } from './PickerItem.types';\nimport * as stylesImport from './BasePicker.scss';\nconst legacyStyles: any = stylesImport;\n\nexport interface IBasePickerState {\n  items?: any;\n  suggestedDisplayValue?: string;\n  moreSuggestionsAvailable?: boolean;\n  isFocused?: boolean;\n  isSearching?: boolean;\n  isMostRecentlyUsedVisible?: boolean;\n  suggestionsVisible?: boolean;\n  suggestionsLoading?: boolean;\n  isResultsFooterVisible?: boolean;\n  selectedIndices?: number[];\n}\n\n/**\n * Aria id's for internal picker components\n * {@docCategory Pickers}\n */\nexport type IPickerAriaIds = {\n  /**\n   * Aria id for selected suggestion alert component\n   */\n  selectedSuggestionAlert: string;\n  /**\n   * Aria id for selected items container component\n   */\n  selectedItems: string;\n  /**\n   * Aria id for suggestions list component\n   */\n  suggestionList: string;\n};\n\nconst getClassNames = classNamesFunction<IBasePickerStyleProps, IBasePickerStyles>();\n\n/**\n * Should be removed once new picker without inheritance is created\n */\nfunction getStyledSuggestions<T>(suggestionsType: new (props: ISuggestionsProps<T>) => Suggestions<T>) {\n  return styled<ISuggestionsProps<any>, ISuggestionsStyleProps, ISuggestionsStyles>(\n    suggestionsType,\n    suggestionsStyles,\n    undefined,\n    {\n      scope: 'Suggestions',\n    },\n  );\n}\n\n/**\n * {@docCategory Pickers}\n */\nexport class BasePicker<T, P extends IBasePickerProps<T>> extends React.Component<P, IBasePickerState>\n  implements IBasePicker<T> {\n  // Refs\n  protected root = React.createRef<HTMLDivElement>();\n  protected input = React.createRef<IAutofill>();\n  protected focusZone = React.createRef<IFocusZone>();\n  protected suggestionElement = React.createRef<ISuggestions<T>>();\n\n  protected selection: Selection;\n  protected suggestionStore: SuggestionsController<T>;\n  /**\n   * @deprecated this is no longer necessary as typescript now supports generic elements\n   */\n  protected SuggestionOfProperType = Suggestions as new (props: ISuggestionsProps<T>) => Suggestions<T>;\n  protected currentPromise: PromiseLike<any> | undefined;\n  protected _ariaMap: IPickerAriaIds;\n  // tslint:disable-next-line:deprecation\n  private _styledSuggestions = getStyledSuggestions(this.SuggestionOfProperType);\n  private _id: string;\n  private _async: Async;\n\n  constructor(basePickerProps: P) {\n    super(basePickerProps);\n\n    initializeComponentRef(this);\n    this._async = new Async(this);\n\n    const items: T[] = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n\n    this._id = getId();\n    this._ariaMap = {\n      selectedItems: `selected-items-${this._id}`,\n      selectedSuggestionAlert: `selected-suggestion-alert-${this._id}`,\n      suggestionList: `suggestion-list-${this._id}`,\n    };\n    this.suggestionStore = new SuggestionsController<T>();\n    this.selection = new Selection({ onSelectionChanged: () => this.onSelectionChange() });\n    this.selection.setItems(items);\n    this.state = {\n      items: items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: [],\n    };\n  }\n\n  public get items(): T[] {\n    return this.state.items;\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillUpdate(newProps: P, newState: IBasePickerState): void {\n    if (newState.items && newState.items !== this.state.items) {\n      this.selection.setItems(newState.items);\n    }\n  }\n\n  public componentDidMount(): void {\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  }\n\n  // tslint:disable-next-line function-name\n  public UNSAFE_componentWillReceiveProps(newProps: P): void {\n    const newItems = newProps.selectedItems;\n\n    if (newItems) {\n      let focusIndex: number;\n\n      // If there are less new items than old items then something was removed and we\n      // should try to keep focus consistent\n      if (newItems.length < this.state.items.length) {\n        focusIndex = this.state.items.indexOf(this.selection.getSelection()[0]);\n      }\n\n      this.setState(\n        {\n          items: newProps.selectedItems,\n        },\n        () => {\n          // Only update the focus if this component is currently focused to ensure that the basepicker\n          // doesn't steal focus from something else.\n          if (this.state.isFocused) {\n            // Need to reset focus in the same that way that we do if an item is selected by a non-controlled component\n            // See _onSelectedItemsUpdated.\n            this.resetFocus(focusIndex);\n          }\n        },\n      );\n    }\n  }\n\n  public componentWillUnmount(): void {\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n    this._async.dispose();\n  }\n\n  public focus() {\n    if (this.focusZone.current) {\n      this.focusZone.current.focus();\n    }\n  }\n\n  public focusInput() {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  }\n\n  public dismissSuggestions = (ev?: any): void => {\n    const selectItemFunction = () => {\n      if (this.props.onDismiss) {\n        this.props.onDismiss(\n          ev,\n          this.suggestionStore.currentSuggestion ? this.suggestionStore.currentSuggestion.item : undefined,\n        );\n      }\n\n      if (!ev || (ev && !ev.defaultPrevented)) {\n        // Select the first suggestion if one is available when user leaves.\n        if (this.canAddItems() && this.suggestionStore.hasSelectedSuggestion() && this.state.suggestedDisplayValue) {\n          this.addItemByIndex(0);\n        }\n      }\n    };\n\n    if (this.currentPromise) {\n      this.currentPromise.then(() => selectItemFunction());\n    } else {\n      selectItemFunction();\n    }\n\n    this.setState({ suggestionsVisible: false });\n  };\n\n  public completeSuggestion(forceComplete?: boolean) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion!.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  }\n\n  public refocusSuggestions = (keyCode: KeyCodes): void => {\n    this.resetFocus();\n    if (this.suggestionStore.suggestions && this.suggestionStore.suggestions.length > 0) {\n      if (keyCode === KeyCodes.up) {\n        this.suggestionStore.setSelectedSuggestion(this.suggestionStore.suggestions.length - 1);\n      } else if (keyCode === KeyCodes.down) {\n        this.suggestionStore.setSelectedSuggestion(0);\n      }\n    }\n  };\n\n  public render(): JSX.Element {\n    const { suggestedDisplayValue, isFocused, items } = this.state;\n    const { className, inputProps, disabled, theme, styles } = this.props;\n\n    const selectedSuggestionAlertId = this.props.enableSelectedSuggestionAlert\n      ? this._ariaMap.selectedSuggestionAlert\n      : '';\n    const suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : '';\n\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    const classNames: Partial<IProcessedStyleSet<IBasePickerStyles>> = styles\n      ? getClassNames(styles, {\n          theme,\n          className,\n          isFocused,\n          disabled,\n          inputClassName: inputProps && inputProps.className,\n        })\n      : {\n          root: css('ms-BasePicker', className ? className : ''),\n          text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n          itemsWrapper: legacyStyles.pickerItems,\n          input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n          screenReaderText: legacyStyles.screenReaderOnly,\n        };\n\n    return (\n      <div ref={this.root} className={classNames.root} onKeyDown={this.onKeyDown} onBlur={this.onBlur}>\n        <FocusZone\n          componentRef={this.focusZone}\n          direction={FocusZoneDirection.bidirectional}\n          shouldEnterInnerZone={this._shouldFocusZoneEnterInnerZone}\n          role={'combobox'}\n          aria-expanded={!!this.state.suggestionsVisible}\n          aria-owns={suggestionsAvailable || undefined}\n          // Dialog is an acceptable child of a combobox according to the aria specs: https://www.w3.org/TR/wai-aria-practices/#combobox\n          // Currently accessibility insights will flag this as not a valid child because the AXE rules are\n          // out of date. Tracking issue: https://github.com/dequelabs/axe-core/issues/1009\n          aria-haspopup={suggestionsAvailable && this.suggestionStore.suggestions.length > 0 ? 'listbox' : 'dialog'}\n        >\n          {this.getSuggestionsAlert(classNames.screenReaderText)}\n          <SelectionZone selection={this.selection} selectionMode={SelectionMode.multiple}>\n            <div className={classNames.text}>\n              {items.length > 0 && (\n                <span id={this._ariaMap.selectedItems} className={classNames.itemsWrapper} role={'list'}>\n                  {this.renderItems()}\n                </span>\n              )}\n              {this.canAddItems() && (\n                <Autofill\n                  spellCheck={false}\n                  {...(inputProps as any)}\n                  className={classNames.input}\n                  componentRef={this.input}\n                  onClick={this.onClick}\n                  onFocus={this.onInputFocus}\n                  onBlur={this.onInputBlur}\n                  onInputValueChange={this.onInputChange}\n                  suggestedDisplayValue={suggestedDisplayValue}\n                  aria-describedby={items.length > 0 ? this._ariaMap.selectedItems : undefined}\n                  aria-controls={`${suggestionsAvailable} ${selectedSuggestionAlertId}` || undefined}\n                  aria-activedescendant={this.getActiveDescendant()}\n                  role={'textbox'}\n                  disabled={disabled}\n                  onInputChange={this.props.onInputChange}\n                />\n              )}\n            </div>\n          </SelectionZone>\n        </FocusZone>\n        {this.renderSuggestions()}\n      </div>\n    );\n  }\n\n  protected canAddItems(): boolean {\n    const { items } = this.state;\n    const { itemLimit } = this.props;\n    return itemLimit === undefined || items.length < itemLimit;\n  }\n\n  protected renderSuggestions(): JSX.Element | null {\n    const StyledTypedSuggestions: React.FunctionComponent<ISuggestionsProps<T>> = this._styledSuggestions;\n\n    return this.state.suggestionsVisible && this.input ? (\n      <Callout\n        isBeakVisible={false}\n        gapSpace={5}\n        target={this.input.current ? this.input.current.inputElement : undefined}\n        onDismiss={this.dismissSuggestions}\n        directionalHint={DirectionalHint.bottomLeftEdge}\n        directionalHintForRTL={DirectionalHint.bottomRightEdge}\n        {...this.props.pickerCalloutProps}\n      >\n        <StyledTypedSuggestions\n          // Assumed to set in derived component's defaultProps\n          onRenderSuggestion={this.props.onRenderSuggestionsItem!}\n          onSuggestionClick={this.onSuggestionClick}\n          onSuggestionRemove={this.onSuggestionRemove}\n          suggestions={this.suggestionStore.getSuggestions()}\n          componentRef={this.suggestionElement}\n          onGetMoreResults={this.onGetMoreResults}\n          moreSuggestionsAvailable={this.state.moreSuggestionsAvailable}\n          isLoading={this.state.suggestionsLoading}\n          isSearching={this.state.isSearching}\n          isMostRecentlyUsedVisible={this.state.isMostRecentlyUsedVisible}\n          isResultsFooterVisible={this.state.isResultsFooterVisible}\n          refocusSuggestions={this.refocusSuggestions}\n          removeSuggestionAriaLabel={this.props.removeButtonAriaLabel}\n          suggestionsListId={this._ariaMap.suggestionList}\n          createGenericItem={this._completeGenericSuggestion}\n          {...this.props.pickerSuggestionsProps}\n        />\n      </Callout>\n    ) : null;\n  }\n\n  protected renderItems(): JSX.Element[] {\n    const { disabled, removeButtonAriaLabel } = this.props;\n    const onRenderItem = this.props.onRenderItem as (props: IPickerItemProps<T>) => JSX.Element;\n\n    const { items, selectedIndices } = this.state;\n    return items.map((item: any, index: number) =>\n      onRenderItem({\n        item,\n        index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices!.indexOf(index) !== -1,\n        onRemoveItem: () => this.removeItem(item, true),\n        disabled: disabled,\n        onItemChange: this.onItemChange,\n        removeButtonAriaLabel: removeButtonAriaLabel,\n      }),\n    );\n  }\n\n  protected resetFocus(index?: number) {\n    const { items } = this.state;\n\n    if (items.length && index! >= 0) {\n      const newEl: HTMLElement | null =\n        this.root.current &&\n        (this.root.current.querySelectorAll('[data-selection-index]')[\n          Math.min(index!, items.length - 1)\n        ] as HTMLElement | null);\n      if (newEl && this.focusZone.current) {\n        this.focusZone.current.focusElement(newEl);\n      }\n    } else if (!this.canAddItems()) {\n      this.resetFocus(items.length - 1);\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  }\n\n  protected onSuggestionSelect() {\n    if (this.suggestionStore.currentSuggestion) {\n      const currentValue: string = this.input.current ? this.input.current.value : '';\n      const itemValue: string = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n      this.setState({ suggestedDisplayValue: itemValue });\n    }\n  }\n\n  protected onSelectionChange() {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices(),\n    });\n  }\n\n  protected updateSuggestions(suggestions: any[]) {\n    this.suggestionStore.updateSuggestions(suggestions, 0);\n    this.forceUpdate();\n  }\n\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n  protected onEmptyInputFocus() {\n    const emptyResolveSuggestions = this.props.onEmptyResolveSuggestions\n      ? this.props.onEmptyResolveSuggestions\n      : // tslint:disable-next-line:deprecation\n        this.props.onEmptyInputFocus;\n\n    // Only attempt to resolve suggestions if it exists\n    if (emptyResolveSuggestions) {\n      const suggestions = emptyResolveSuggestions(this.state.items);\n\n      this.updateSuggestionsList(suggestions);\n\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false,\n      });\n    }\n  }\n\n  protected updateValue(updatedValue: string) {\n    this._onResolveSuggestions(updatedValue);\n  }\n\n  protected updateSuggestionsList(suggestions: T[] | PromiseLike<T[]>, updatedValue?: string) {\n    const suggestionsArray: T[] = suggestions as T[];\n    const suggestionsPromiseLike: PromiseLike<T[]> = suggestions as PromiseLike<T[]>;\n\n    // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n    if (Array.isArray(suggestionsArray)) {\n      this._updateAndResolveValue(updatedValue, suggestionsArray);\n    } else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {\n      this.setState({\n        suggestionsLoading: true,\n      });\n\n      // Clear suggestions\n      this.suggestionStore.updateSuggestions([]);\n\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions(),\n        });\n      } else {\n        this.setState({\n          suggestionsVisible: this.input.current! && this.input.current!.inputElement === document.activeElement,\n        });\n      }\n\n      // Ensure that the promise will only use the callback if it was the most recent one.\n      const promise: PromiseLike<T[]> = (this.currentPromise = suggestionsPromiseLike);\n      promise.then((newSuggestions: T[]) => {\n        if (promise === this.currentPromise) {\n          this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  }\n\n  protected resolveNewValue(updatedValue: string, suggestions: T[]) {\n    this.updateSuggestions(suggestions);\n    let itemValue: string | undefined = undefined;\n\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    }\n\n    // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n    this.setState(\n      {\n        suggestedDisplayValue: itemValue,\n        suggestionsVisible: this._getShowSuggestions(),\n      },\n      () => this.setState({ suggestionsLoading: false }),\n    );\n  }\n\n  protected onChange(items?: T[]) {\n    if (this.props.onChange) {\n      (this.props.onChange as any)(items);\n    }\n  }\n\n  protected onInputChange = (value: string): void => {\n    this.updateValue(value);\n    this.setState({\n      moreSuggestionsAvailable: true,\n      isMostRecentlyUsedVisible: false,\n    });\n  };\n\n  protected onSuggestionClick = (ev: React.MouseEvent<HTMLElement>, item: any, index: number): void => {\n    this.addItemByIndex(index);\n  };\n\n  protected onSuggestionRemove = (ev: React.MouseEvent<HTMLElement>, item: T, index: number): void => {\n    if (this.props.onRemoveSuggestion) {\n      this.props.onRemoveSuggestion(item);\n    }\n    this.suggestionStore.removeSuggestion(index);\n  };\n\n  protected onInputFocus = (ev: React.FocusEvent<HTMLInputElement | Autofill>): void => {\n    // Only trigger all of the focus if this component isn't already focused.\n    // For example when an item is selected or removed from the selected list it should be treated\n    // as though the input is still focused.\n    if (!this.state.isFocused) {\n      this.setState({ isFocused: true });\n      this.selection.setAllSelected(false);\n\n      this._userTriggeredSuggestions();\n\n      if (this.props.inputProps && this.props.inputProps.onFocus) {\n        this.props.inputProps.onFocus(ev as React.FocusEvent<HTMLInputElement>);\n      }\n    }\n  };\n\n  protected onInputBlur = (ev: React.FocusEvent<HTMLInputElement | Autofill>): void => {\n    if (this.props.inputProps && this.props.inputProps.onBlur) {\n      this.props.inputProps.onBlur(ev as React.FocusEvent<HTMLInputElement>);\n    }\n  };\n\n  protected onBlur = (ev: React.FocusEvent<HTMLElement | Autofill>): void => {\n    if (this.state.isFocused) {\n      // Only blur the entire component if an unrelated element gets focus.\n      // Otherwise treat it as though it still has focus.\n      // Do nothing if the blur is coming from something\n      // inside the comboBox root or the comboBox menu since\n      // it we are not really bluring from the whole comboBox\n      let relatedTarget: EventTarget | null = ev.relatedTarget;\n\n      if (ev.relatedTarget === null) {\n        // In IE11, due to lack of support, event.relatedTarget is always\n        // null making every onBlur call to be \"outside\" of the ComboBox\n        // even when it's not. Using document.activeElement is another way\n        // for us to be able to get what the relatedTarget without relying\n        // on the event\n        relatedTarget = document.activeElement;\n      }\n      if (relatedTarget && !elementContains(this.root.current!, relatedTarget as HTMLElement)) {\n        this.setState({ isFocused: false });\n        if (this.props.onBlur) {\n          this.props.onBlur(ev as React.FocusEvent<HTMLInputElement>);\n        }\n      }\n    }\n  };\n\n  /**\n   * Reveals suggestions any time the user clicks on the input element\n   * without shifting focus.\n   */\n  protected onClick = (ev: React.MouseEvent<HTMLInputElement>): void => {\n    if (this.props.inputProps !== undefined && this.props.inputProps.onClick !== undefined) {\n      this.props.inputProps.onClick(ev);\n    }\n\n    // Only primary (left) clicks show suggestions.\n    if (ev.button === 0) {\n      this._userTriggeredSuggestions();\n    }\n  };\n\n  protected onKeyDown = (ev: React.KeyboardEvent<HTMLElement>): void => {\n    const keyCode = ev.which;\n    switch (keyCode) {\n      case KeyCodes.escape:\n        if (this.state.suggestionsVisible) {\n          this.setState({ suggestionsVisible: false });\n          ev.preventDefault();\n          ev.stopPropagation();\n        }\n        break;\n\n      case KeyCodes.tab:\n      case KeyCodes.enter:\n        if (this.suggestionElement.current && this.suggestionElement.current.hasSuggestedActionSelected()) {\n          this.suggestionElement.current.executeSelectedAction();\n        } else if (!ev.shiftKey && this.suggestionStore.hasSelectedSuggestion() && this.state.suggestionsVisible) {\n          this.completeSuggestion();\n          ev.preventDefault();\n          ev.stopPropagation();\n        } else {\n          this._completeGenericSuggestion();\n        }\n\n        break;\n\n      case KeyCodes.backspace:\n        if (!this.props.disabled) {\n          this.onBackspace(ev);\n        }\n        ev.stopPropagation();\n        break;\n\n      case KeyCodes.del:\n        if (!this.props.disabled) {\n          if (\n            this.input.current &&\n            ev.target === this.input.current.inputElement &&\n            this.state.suggestionsVisible &&\n            this.suggestionStore.currentIndex !== -1\n          ) {\n            if (this.props.onRemoveSuggestion) {\n              this.props.onRemoveSuggestion(this.suggestionStore.currentSuggestion!.item);\n            }\n            this.suggestionStore.removeSuggestion(this.suggestionStore.currentIndex);\n            this.forceUpdate();\n          } else {\n            this.onBackspace(ev);\n          }\n        }\n        ev.stopPropagation();\n        break;\n\n      case KeyCodes.up:\n        if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {\n          if (\n            this.suggestionElement.current &&\n            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)\n          ) {\n            ev.preventDefault();\n            ev.stopPropagation();\n          } else {\n            if (\n              this.suggestionElement.current &&\n              this.suggestionElement.current.hasSuggestedAction() &&\n              this.suggestionStore.currentIndex === 0\n            ) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              this.suggestionElement.current.focusAboveSuggestions();\n              this.suggestionStore.deselectAllSuggestions();\n              this.forceUpdate();\n            } else {\n              if (this.suggestionStore.previousSuggestion()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.onSuggestionSelect();\n              }\n            }\n          }\n        }\n        break;\n\n      case KeyCodes.down:\n        if (this.input.current && ev.target === this.input.current.inputElement && this.state.suggestionsVisible) {\n          if (\n            this.suggestionElement.current &&\n            this.suggestionElement.current.tryHandleKeyDown(keyCode, this.suggestionStore.currentIndex)\n          ) {\n            ev.preventDefault();\n            ev.stopPropagation();\n          } else {\n            if (\n              this.suggestionElement.current &&\n              this.suggestionElement.current.hasSuggestedAction() &&\n              this.suggestionStore.currentIndex + 1 === this.suggestionStore.suggestions.length\n            ) {\n              ev.preventDefault();\n              ev.stopPropagation();\n              this.suggestionElement.current.focusBelowSuggestions();\n              this.suggestionStore.deselectAllSuggestions();\n              this.forceUpdate();\n            } else {\n              if (this.suggestionStore.nextSuggestion()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.onSuggestionSelect();\n              }\n            }\n          }\n        }\n        break;\n    }\n  };\n\n  protected onItemChange = (changedItem: T, index: number): void => {\n    const { items } = this.state;\n\n    if (index >= 0) {\n      const newItems: T[] = items;\n      newItems[index] = changedItem;\n\n      this._updateSelectedItems(newItems);\n    }\n  };\n\n  protected onGetMoreResults = (): void => {\n    this.setState(\n      {\n        isSearching: true,\n      },\n      () => {\n        if (this.props.onGetMoreResults && this.input.current) {\n          const suggestions: T[] | PromiseLike<T[]> = (this.props.onGetMoreResults as any)(\n            this.input.current.value,\n            this.state.items,\n          );\n          const suggestionsArray: T[] = suggestions as T[];\n          const suggestionsPromiseLike: PromiseLike<T[]> = suggestions as PromiseLike<T[]>;\n\n          if (Array.isArray(suggestionsArray)) {\n            this.updateSuggestions(suggestionsArray);\n            this.setState({ isSearching: false });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then((newSuggestions: T[]) => {\n              this.updateSuggestions(newSuggestions);\n              this.setState({ isSearching: false });\n            });\n          }\n        } else {\n          this.setState({ isSearching: false });\n        }\n\n        if (this.input.current) {\n          this.input.current.focus();\n        }\n\n        this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true,\n        });\n      },\n    );\n  };\n\n  protected completeSelection = (item: T) => {\n    this.addItem(item);\n    this.updateValue('');\n    if (this.input.current) {\n      this.input.current.clear();\n    }\n    this.setState({ suggestionsVisible: false });\n  };\n\n  protected addItemByIndex = (index: number): void => {\n    this.completeSelection(this.suggestionStore.getSuggestionAtIndex(index).item);\n  };\n\n  protected addItem = (item: T): void => {\n    const processedItem: T | PromiseLike<T> | null = this.props.onItemSelected\n      ? (this.props.onItemSelected as any)(item)\n      : item;\n\n    if (processedItem === null) {\n      return;\n    }\n\n    const processedItemObject: T = processedItem as T;\n    const processedItemPromiseLike: PromiseLike<T> = processedItem as PromiseLike<T>;\n\n    if (processedItemPromiseLike && processedItemPromiseLike.then) {\n      processedItemPromiseLike.then((resolvedProcessedItem: T) => {\n        const newItems: T[] = this.state.items.concat([resolvedProcessedItem]);\n        this._updateSelectedItems(newItems);\n      });\n    } else {\n      const newItems: T[] = this.state.items.concat([processedItemObject]);\n      this._updateSelectedItems(newItems);\n    }\n    this.setState({ suggestedDisplayValue: '' });\n  };\n\n  protected removeItem = (item: IPickerItemProps<T>, focusNextItem?: boolean): void => {\n    const { items } = this.state;\n    const index: number = items.indexOf(item);\n\n    if (index >= 0) {\n      const newItems: T[] = items.slice(0, index).concat(items.slice(index + 1));\n      this._updateSelectedItems(newItems, focusNextItem ? index : undefined);\n    }\n  };\n\n  protected removeItems = (itemsToRemove: any[]): void => {\n    const { items } = this.state;\n    const newItems: T[] = items.filter((item: any) => itemsToRemove.indexOf(item) === -1);\n    const firstItemToRemove = itemsToRemove[0];\n    const index: number = items.indexOf(firstItemToRemove);\n\n    this._updateSelectedItems(newItems, index);\n  };\n\n  // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n  protected onBackspace(ev: React.KeyboardEvent<HTMLElement>) {\n    if (\n      (this.state.items.length && !this.input.current) ||\n      (this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0)\n    ) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  }\n\n  protected _shouldFocusZoneEnterInnerZone = (ev: React.KeyboardEvent<HTMLElement>): boolean => {\n    // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n    if (this.state.suggestionsVisible) {\n      switch (ev.which) {\n        case KeyCodes.up:\n        case KeyCodes.down:\n          return true;\n      }\n    }\n\n    if (ev.which === KeyCodes.enter) {\n      return true;\n    }\n\n    return false;\n  };\n\n  protected getActiveDescendant() {\n    const currentIndex = this.suggestionStore.currentIndex;\n    return currentIndex > -1 && !this.state.suggestionsLoading ? 'sug-' + currentIndex : undefined;\n  }\n\n  protected getSuggestionsAlert(suggestionAlertClassName: string = legacyStyles.screenReaderOnly) {\n    const currentIndex = this.suggestionStore.currentIndex;\n    if (this.props.enableSelectedSuggestionAlert) {\n      const selectedSuggestion =\n        currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      const selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;\n      return (\n        <div\n          className={suggestionAlertClassName}\n          role=\"alert\"\n          id={this._ariaMap.selectedSuggestionAlert}\n          aria-live=\"assertive\"\n        >\n          {selectedSuggestionAlertText}{' '}\n        </div>\n      );\n    }\n  }\n\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n  private _updateAndResolveValue(updatedValue: string | undefined, newSuggestions: T[]) {\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      this.suggestionStore.updateSuggestions(newSuggestions, -1);\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false,\n        });\n      }\n    }\n  }\n\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n  private _updateSelectedItems(items: T[], focusIndex?: number): void {\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({ items: items }, () => {\n        this._onSelectedItemsUpdated(items, focusIndex);\n      });\n    }\n  }\n\n  private _onSelectedItemsUpdated(items?: T[], focusIndex?: number): void {\n    this.resetFocus(focusIndex);\n    this.onChange(items);\n  }\n\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n  private _getShowSuggestions(): boolean {\n    const areSuggestionsVisible =\n      this.input.current !== undefined &&\n      this.input.current !== null &&\n      this.input.current.inputElement === document.activeElement &&\n      this.input.current.value !== '';\n\n    return areSuggestionsVisible;\n  }\n\n  private _onResolveSuggestions = (updatedValue: string): void => {\n    const suggestions: T[] | PromiseLike<T[]> | null = this.props.onResolveSuggestions(updatedValue, this.state.items);\n\n    if (suggestions !== null) {\n      this.updateSuggestionsList(suggestions, updatedValue);\n    }\n  };\n\n  private _completeGenericSuggestion = (): void => {\n    if (\n      this.props.onValidateInput &&\n      this.input.current &&\n      (this.props.onValidateInput as any)(this.input.current.value) !== ValidationState.invalid &&\n      this.props.createGenericItem\n    ) {\n      const itemToConvert = this.props.createGenericItem(\n        this.input.current.value,\n        this.props.onValidateInput(this.input.current.value),\n      );\n      this.suggestionStore.createGenericSuggestion(itemToConvert);\n      this.completeSuggestion();\n    }\n  };\n\n  private _getTextFromItem(item: T, currentValue?: string): string {\n    if (this.props.getTextFromItem) {\n      return (this.props.getTextFromItem as any)(item, currentValue);\n    } else {\n      return '';\n    }\n  }\n\n  /**\n   * This should be called when the user does something other than use text entry to trigger suggestions.\n   *\n   */\n  private _userTriggeredSuggestions = () => {\n    if (!this.state.suggestionsVisible) {\n      const input = this.input.current ? this.input.current.value : '';\n      if (!input) {\n        this.onEmptyInputFocus();\n      } else {\n        if (this.suggestionStore.suggestions.length === 0) {\n          this._onResolveSuggestions(input);\n        } else {\n          this.setState({\n            isMostRecentlyUsedVisible: false,\n            suggestionsVisible: true,\n          });\n        }\n      }\n    }\n  };\n}\n\nexport class BasePickerListBelow<T, P extends IBasePickerProps<T>> extends BasePicker<T, P> {\n  public render(): JSX.Element {\n    const { suggestedDisplayValue, isFocused } = this.state;\n    const { className, inputProps, disabled, theme, styles } = this.props;\n\n    const selectedSuggestionAlertId: string | undefined = this.props.enableSelectedSuggestionAlert\n      ? this._ariaMap.selectedSuggestionAlert\n      : '';\n    const suggestionsAvailable: string | undefined = this.state.suggestionsVisible ? this._ariaMap.suggestionList : '';\n\n    // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n    const classNames: Partial<IProcessedStyleSet<IBasePickerStyles>> = styles\n      ? getClassNames(styles, {\n          theme,\n          className,\n          isFocused,\n          inputClassName: inputProps && inputProps.className,\n        })\n      : {\n          root: css('ms-BasePicker', className ? className : ''),\n          text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n          input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n          screenReaderText: legacyStyles.screenReaderOnly,\n        };\n\n    return (\n      <div ref={this.root} onBlur={this.onBlur}>\n        <div className={classNames.root} onKeyDown={this.onKeyDown}>\n          {this.getSuggestionsAlert(classNames.screenReaderText)}\n          <div\n            className={classNames.text}\n            aria-owns={suggestionsAvailable || undefined}\n            aria-expanded={!!this.state.suggestionsVisible}\n            // Dialog is an acceptable child of a combobox according to the aria specs: https://www.w3.org/TR/wai-aria-practices/#combobox\n            // Currently accessibility insights will flag this as not a valid child because the AXE rules are\n            // out of date. Tracking issue: https://github.com/dequelabs/axe-core/issues/1009\n            aria-haspopup={suggestionsAvailable && this.suggestionStore.suggestions.length > 0 ? 'listbox' : 'dialog'}\n            role=\"combobox\"\n          >\n            <Autofill\n              {...(inputProps as any)}\n              className={classNames.input}\n              componentRef={this.input}\n              onFocus={this.onInputFocus}\n              onBlur={this.onInputBlur}\n              onClick={this.onClick}\n              onInputValueChange={this.onInputChange}\n              suggestedDisplayValue={suggestedDisplayValue}\n              aria-activedescendant={this.getActiveDescendant()}\n              role=\"textbox\"\n              disabled={disabled}\n              aria-controls={`${suggestionsAvailable} ${selectedSuggestionAlertId}` || undefined}\n              onInputChange={this.props.onInputChange}\n            />\n          </div>\n        </div>\n        {this.renderSuggestions()}\n        <SelectionZone selection={this.selection} selectionMode={SelectionMode.single}>\n          <FocusZone\n            componentRef={this.focusZone}\n            className=\"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n            isCircularNavigation={true}\n            direction={FocusZoneDirection.bidirectional}\n            shouldEnterInnerZone={this._shouldFocusZoneEnterInnerZone}\n            id={this._ariaMap.selectedItems}\n            role={'list'}\n          >\n            {this.renderItems()}\n          </FocusZone>\n        </SelectionZone>\n      </div>\n    );\n  }\n\n  protected onBackspace(ev: React.KeyboardEvent<HTMLElement>) {\n    // override the existing backspace method to not do anything because the list items appear below.\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}