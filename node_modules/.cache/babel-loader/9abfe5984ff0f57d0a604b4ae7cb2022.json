{"ast":null,"code":"import * as React from 'react';\nimport { useConst } from './useConst';\nexport function useControllableValue(controlledValue, defaultUncontrolledValue, onChange) {\n  var _a = React.useState(defaultUncontrolledValue),\n      value = _a[0],\n      setValue = _a[1];\n\n  var isControlled = useConst(controlledValue !== undefined);\n  var setValueOrCallOnChange = React.useCallback(function (newValue, ev) {\n    if (onChange) {\n      onChange(ev, newValue);\n    }\n\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  }, [onChange]);\n  return [isControlled ? controlledValue : value, setValueOrCallOnChange];\n}","map":{"version":3,"sources":["useControllableValue.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,QAAT,QAAyB,YAAzB;AA4BA,OAAM,SAAU,oBAAV,CAIJ,eAJI,EAIiC,wBAJjC,EAI+E,QAJ/E,EAImG;AACjG,MAAA,EAAA,GAAA,KAAA,CAAA,QAAA,CAAA,wBAAA,CAAA;AAAA,MAAC,KAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAQ,QAAA,GAAA,EAAA,CAAA,CAAA,CAAR;;AACN,MAAM,YAAY,GAAG,QAAQ,CAAU,eAAe,KAAK,SAA9B,CAA7B;AAEA,MAAM,sBAAsB,GAAG,KAAK,CAAC,WAAN,CAC7B,UAAC,QAAD,EAA+B,EAA/B,EAA6D;AAC3D,QAAI,QAAJ,EAAc;AACZ,MAAA,QAAQ,CAAC,EAAD,EAAM,QAAN,CAAR;AACD;;AACD,QAAI,CAAC,YAAL,EAAmB;AACjB,MAAA,QAAQ,CAAC,QAAD,CAAR;AACD;AACF,GAR4B,EAS7B,CAAC,QAAD,CAT6B,CAA/B;AAYA,SAAO,CAAC,YAAY,GAAG,eAAH,GAAqB,KAAlC,EAAyC,sBAAzC,CAAP;AACD","sourcesContent":["import * as React from 'react';\nimport { useConst } from './useConst';\n\nexport type ChangeCallback<TElement extends HTMLElement, TValue> = (\n  ev: React.FormEvent<TElement> | undefined,\n  newValue: TValue | undefined,\n) => void;\n\n/**\n * Hook to manage a value that could be either controlled or uncontrolled, such as a checked state or\n * text box string.\n * @param controlledValue- The controlled value passed in the props. This value will always be used if provided, and the\n * internal state will be updated to reflect it.\n * @param defaultUncontrolledValue- Initial value for the internal state in the uncontrolled case.\n * @see https://reactjs.org/docs/uncontrolled-components.html\n */\nexport function useControllableValue<TValue, TElement extends HTMLElement>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n): Readonly<[TValue | undefined, (newValue: TValue | undefined) => void]>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TCallback extends ChangeCallback<TElement, TValue> | undefined\n>(\n  controlledValue: TValue | undefined,\n  defaultUncontrolledValue: TValue | undefined,\n  onChange: TCallback,\n): Readonly<[TValue | undefined, (newValue: TValue | undefined, ev?: React.FormEvent<TElement>) => void]>;\nexport function useControllableValue<\n  TValue,\n  TElement extends HTMLElement,\n  TCallback extends ChangeCallback<TElement, TValue> | undefined\n>(controlledValue: TValue | undefined, defaultUncontrolledValue: TValue | undefined, onChange?: TCallback) {\n  const [value, setValue] = React.useState<TValue | undefined>(defaultUncontrolledValue);\n  const isControlled = useConst<boolean>(controlledValue !== undefined);\n\n  const setValueOrCallOnChange = React.useCallback(\n    (newValue: TValue | undefined, ev?: React.FormEvent<TElement>) => {\n      if (onChange) {\n        onChange(ev!, newValue);\n      }\n      if (!isControlled) {\n        setValue(newValue);\n      }\n    },\n    [onChange],\n  );\n\n  return [isControlled ? controlledValue : value, setValueOrCallOnChange] as const;\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}